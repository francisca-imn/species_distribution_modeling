oeste = coords_arclim[which.min(coords_arclim[,1]),]
)
extremes_pred <- list(
norte = coords_pred[which.max(coords_pred[,2]),],
sur = coords_pred[which.min(coords_pred[,2]),],
este = coords_pred[which.max(coords_pred[,1]),],
oeste = coords_pred[which.min(coords_pred[,1]),]
)
# Seleccionar la coordenada extrema global
extreme_global <- list(
norte = if (extremes_arclim$norte[2] > extremes_pred$norte[2]) extremes_arclim$norte else extremes_pred$norte,
sur = if (extremes_arclim$sur[2] < extremes_pred$sur[2]) extremes_arclim$sur else extremes_pred$sur,
este = if (extremes_arclim$este[1] > extremes_pred$este[1]) extremes_arclim$este else extremes_pred$este,
oeste = if (extremes_arclim$oeste[1] < extremes_pred$oeste[1]) extremes_arclim$oeste else extremes_pred$oeste
)
# Definir la extensiÃ³n del recorte basado en el cuadrado rojo
recorte_extent <- ext(extreme_global$oeste[1], extreme_global$este[1], extreme_global$sur[2], extreme_global$norte[2])
# Recortar ambos mapas al cuadrado definido
arclim_recortado <- crop(arclim_binary, recorte_extent)
pred_recortado <- crop(pred_binary, recorte_extent)
# Guardar los mapas recortados como archivos .tif
writeRaster(arclim_recortado, "arclim_recortado.tif", overwrite=TRUE)
# Imprimir resultados
print("Extremos Globales (mÃ¡ximos entre ambos mapas):")
print(extreme_global)
print("Archivos .tif generados: arclim_recortado.tif y pred_recortado.tif")
# VisualizaciÃ³n de los mapas binarios recortados
plot(arclim_recortado, main="Mapa ARClim Recortado")
plot(pred_recortado, main="Mapa PredicciÃ³n Recortado")
library(httr)
library(terra)
library(sf)
library(dismo)
library(jsonlite)
# ðŸ“Œ Variables actuales (presente) -------------------------------------------
url_base <- "https://arclim.mma.gob.cl/api/datos"  # URL base de la API ARClim
variables <- c("eto_mean", "pr_sum", "rsds_mean", "tasmin_mean", "tasmax_mean")  # Lista de variables climÃ¡ticas a descargar
raster_list_present <- list()  # Crear una lista vacÃ­a para almacenar los rasters
for (var in variables) {  # Descargar y procesar cada variable climÃ¡tica
atributos_present <- paste0("$CLIMA$", var, "$annual$present")  # Construir la URL con el nombre de la variable
url_present <- paste0(url_base, "/arclim_raster_5km/geojson/?attributes=", URLencode(atributos_present))
response_present <- GET(url_present)  # Realizar la consulta a la API
if (status_code(response_present) == 200) {  # Verificar si la respuesta fue exitosa
geojson_file_present <- tempfile(fileext = ".geojson")  # Guardar datos descargados como archivo temporal
writeBin(content(response_present, "raw"), geojson_file_present)
vect_data_present <- vect(geojson_file_present)  # Cargar los datos como un objeto SpatVector
raster_data_present <- rast(vect_data_present, resolution = 0.05)  # Crear un raster con la misma resoluciÃ³n para todas las capas
raster_data_present <- rasterize(vect_data_present, raster_data_present, field = atributos_present)  # Usa la variable correcta
raster_list_present[[var]] <- raster_data_present
} else {
print(paste("âŒ Error al descargar", var, "- CÃ³digo:", status_code(response_present)))  # âœ… Error corregido
}
}
capas_present <- rast(raster_list_present) # Combinar todas las capas en un solo objeto SpatRaster
print(capas_present)
plot(capas_present)
# ðŸ“Œ Variables futuras (proyecciones) -------------------------------------------
url_base <- "https://arclim.mma.gob.cl/api/datos"  # URL base de la API ARClim
variables <- c("eto_mean", "pr_sum", "rsds_mean", "tasmin_mean", "tasmax_mean")  # Lista de variables climÃ¡ticas a descargar
raster_list_future <- list()  # Crear una lista vacÃ­a para almacenar los rasters
for (var in variables) {  # Descargar y procesar cada variable climÃ¡tica futura
atributos_future <- paste0("$CLIMA$", var, "$annual$future")
url_future <- paste0(url_base, "/arclim_raster_5km/geojson/?attributes=", URLencode(atributos_future))
response_future <- GET(url_future)  # Realizar la consulta a la API
if (status_code(response_future) == 200) {  # Verificar si la respuesta fue exitosa
geojson_file_future <- tempfile(fileext = ".geojson")  # Guardar datos descargados como archivo temporal
writeBin(content(response_future, "raw"), geojson_file_future)
vect_data_future <- vect(geojson_file_future)  # Cargar los datos como un objeto SpatVector
raster_data_future <- rast(vect_data_future, resolution = 0.05)  # Crear un raster con la misma resoluciÃ³n para todas las capas
raster_data_future <- rasterize(vect_data_future, raster_data_future, field = atributos_future)  # Usa la variable correcta
raster_list_future[[var]] <- raster_data_future  # âœ… Guardar raster correctamente en la lista
} else {
print(paste("âŒ Error al descargar", var, "- CÃ³digo:", status_code(response_future)))  # âœ… CORREGIDO: error de sintaxis
}
}
# ðŸ“Œ Combinar todas las capas en un solo objeto SpatRaster ----------------------
capas_future <- rast(raster_list_future)
# ðŸ“Š Mostrar informaciÃ³n del stack futuro
print(capas_future)
plot(capas_future)  # âœ… Graficar correctamente las capas
library(rgbif)
library(tidyverse)
library(httr)
library(rnaturalearth)
library(rnaturalearthdata)
library(rJava)
# Obteniendo data de GBIF -------------------------------------------------
especie_info <- name_backbone(name = "Adesmia atacamensis")  #cambiar el nombre por el de la especie de interÃ©s
especie_data <- occ_search(taxonKey = especie_info$usageKey,
country = "CL",                    #solo datos de Chile
hasCoordinate = TRUE,              #solo registros con coordenadas
hasGeospatialIssue = FALSE,
limit = 5000)        #sin problemas espaciales
data_ocurrencias <- especie_data$data
View(data_ocurrencias)
# en base a observaciones -------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias %>%
filter(basisOfRecord %in% c("HUMAN_OBSERVATION", "MACHINE_OBSERVATION"))
# Eliminar datos de iNaturalist.org ---------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(publishingOrgKey != "28eb1a3f-1c15-4a95-931a-4af90ecb574d")  #esto es equivalente a references, reemplazar por los cÃ³digos que no son fuentes confiables
# en base a observaciones -------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias %>%
filter(basisOfRecord %in% c("HUMAN_OBSERVATION", "MACHINE_OBSERVATION"))
# PrecisiÃ³n espacial adecuada ---------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(coordinateUncertaintyInMeters <= 1000 | is.na(coordinateUncertaintyInMeters))  # Incertidumbre < 1 km
# cautiverio o zoo --------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(!grepl("zoo|captive|rescue", locality, ignore.case = TRUE))
# calidad taxonÃ³mica ------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(taxonRank == "SPECIES", taxonomicStatus == "ACCEPTED")
# evitar duplicados -------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
distinct(decimalLongitude, decimalLatitude, year, .keep_all = TRUE)
# ðŸ“Š Resultados y visualizaciÃ³n -------------------------------------------
print(paste("Registros originales:", nrow(data_ocurrencias)))
print(paste("Registros filtrados:", nrow(data_ocurrencias_filtered)))
# ðŸ“Œ Mantener solo las columnas de coordenadas ----------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
select(decimalLongitude, decimalLatitude)
source("C:/Users/fmnar/OneDrive/Escritorio/cienciambiental/codigo/02_datos_ocurrencia_gbif.R")
# en base a observaciones -------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias %>%
filter(basisOfRecord %in% c("HUMAN_OBSERVATION", "MACHINE_OBSERVATION"))
# PrecisiÃ³n espacial adecuada ---------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(coordinateUncertaintyInMeters <= 1000 | is.na(coordinateUncertaintyInMeters))  # Incertidumbre < 1 km
# cautiverio o zoo --------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(!grepl("zoo|captive|rescue", locality, ignore.case = TRUE))
# calidad taxonÃ³mica ------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
filter(taxonRank == "SPECIES", taxonomicStatus == "ACCEPTED")
# evitar duplicados -------------------------------------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
distinct(decimalLongitude, decimalLatitude, year, .keep_all = TRUE)
# ðŸ“Š Resultados y visualizaciÃ³n -------------------------------------------
print(paste("Registros originales:", nrow(data_ocurrencias)))
print(paste("Registros filtrados:", nrow(data_ocurrencias_filtered)))
# ðŸ“Œ Mantener solo las columnas de coordenadas ----------------------------
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%
select(decimalLongitude, decimalLatitude)
library(sp)
library(dismo)
library(raster)
# Arreglando datos de entrada ---------------------------------------------
capas_present_raster <- raster::stack(capas_present) # Convertir SpatRaster a RasterStack (para que lo acepte maxent)
capas_future_raster <- raster::stack(capas_future)
data_ocurrencias_filtered <- data_ocurrencias_filtered %>%  # Asegurar que data_ocurrencias_filtered sea un data.frame con solo coordenadas
select(decimalLongitude, decimalLatitude) %>%
as.data.frame()
# ðŸ“Œ Ejecutar Maxent ------------------------------------------------------
model <- maxent(capas_present_raster, data_ocurrencias_filtered)
pred_present <- predict(model, capas_present_raster)
pred_future <- predict(model, capas_future_raster)
# Valos promedios de ocurrencia -------------------------------------------
prob_present_mean <- cellStats(pred_present, stat = "mean", na.rm = TRUE)
prob_future_mean <- cellStats(pred_future, stat = "mean", na.rm = TRUE)
library(RColorBrewer)
# cargar capas de arclim --------------------------------------------------
zip_path <- "data/arclim_adesmia_atacamensis.zip"  #cambiar por la especie correspondiente
files_in_zip <- unzip(zip_path, list = TRUE) # Listar los archivos dentro del ZIP
tif_files <- files_in_zip$Name[grepl("\\.tif$", files_in_zip$Name)] # Filtrar solo los archivos .tif dentro del ZIP
temp_dir <- tempdir()  # Crear un directorio temporal para extraer los archivos
unzip(zip_path, files = tif_files, exdir = temp_dir)  # Extraer los archivos .tif en la carpeta temporal
rasters <- lapply(tif_files, function(file) {  # Cargar los rasters desde la carpeta temporal
rast(file.path(temp_dir, file))
})
names(rasters) <- c("arclim_present", "arclim_future")  # Ajustar los nombres segÃºn corresponda
arclim_present <- rasters[[1]] # Extraer los mapas en variables individuales
arclim_future <- rasters[[2]]
# probabilidades ----------------------------------------------------------
prob_present_mean_arclim <- global(arclim_present, "mean", na.rm = TRUE)
prob_future_mean_arclim <- global(arclim_future, "mean", na.rm = TRUE)
pred_present_spat <- rast(pred_present)  # Convertir pred_present (RasterLayer) a SpatRaster
pred_present_proj <- project(pred_present_spat, arclim_present, method = "bilinear")  # Reproyectar pred_present para que tenga la misma proyecciÃ³n que arclim_present
pred_present_resampled <- resample(pred_present_proj, arclim_present, method = "bilinear")  # Ajustar resoluciÃ³n y extensiÃ³n para que coincidan con arclim_present
pred_present_resampled <- extend(pred_present_resampled, arclim_present)  # Asegurar que la extensiÃ³n es exactamente la misma
common_range <- range(values(arclim_present), values(pred_present_resampled), na.rm = TRUE)
pred_future_spat <- rast(pred_future)  # Convertir pred_present (RasterLayer) a SpatRaster
pred_future_proj <- project(pred_future_spat, arclim_future, method = "bilinear")  # Reproyectar pred_present para que tenga la misma proyecciÃ³n que arclim_present
pred_future_resampled <- resample(pred_future_proj, arclim_future, method = "bilinear")  # Ajustar resoluciÃ³n y extensiÃ³n para que coincidan con arclim_present
pred_future_resampled <- extend(pred_future_resampled, arclim_future)  # Asegurar que la extensiÃ³n es exactamente la misma
common_range_future <- range(values(arclim_future), values(pred_future_resampled), na.rm = TRUE)
# graficar comparacion arclim-dismo 1980-2010 -----------------------------
my_palette <- colorRampPalette(brewer.pal(9, "YlGnBu"))  # Amarillo - Verde - Azul
par(mfcol = c(1,2))
plot(pred_present_resampled,
main = "Probabilidad de ocurrencia \nA. atacamensis DISMO 1980-2010",
xlim = c(-77, -66), ylim = c(-56, -17), asp=1,
zlim = common_range,
col = my_palette(100),
cex.main = 0.85)
mtext(paste("Promedio:", round(prob_present_mean_arclim, 3)), side = 1, line = 3, cex = 0.8)
plot(arclim_present,
main = "Probabilidad ocurrencia \nA. atacamensis ARCLIM 1980-2010",
xlim = c(-77, -66), ylim = c(-56, -17), asp=1,
zlim = common_range,
col = my_palette(100),
cex.main = 0.85)
mtext(paste("Promedio:", round(prob_present_mean, 3)), side = 1, line = 3, cex = 0.8)
# Transformar los mapas a binario con umbral de 0.1
arclim_binary <- arclim_present >= 0.1
pred_binary <- pred_present_resampled >= 0.1
# Encontrar los pÃ­xeles con valor 1 en cada mapa
arclim_cells <- which(arclim_binary[] == 1)
pred_cells <- which(pred_binary[] == 1)
# Obtener coordenadas de los pÃ­xeles con valor 1
coords_arclim <- xyFromCell(arclim_binary, arclim_cells)
coords_pred <- xyFromCell(pred_binary, pred_cells)
# Encontrar los extremos de CADA MAPA
extremes_arclim <- list(
norte = coords_arclim[which.max(coords_arclim[,2]),],
sur = coords_arclim[which.min(coords_arclim[,2]),],
este = coords_arclim[which.max(coords_arclim[,1]),],
oeste = coords_arclim[which.min(coords_arclim[,1]),]
)
extremes_pred <- list(
norte = coords_pred[which.max(coords_pred[,2]),],
sur = coords_pred[which.min(coords_pred[,2]),],
este = coords_pred[which.max(coords_pred[,1]),],
oeste = coords_pred[which.min(coords_pred[,1]),]
)
# Seleccionar la coordenada extrema global
extreme_global <- list(
norte = if (extremes_arclim$norte[2] > extremes_pred$norte[2]) extremes_arclim$norte else extremes_pred$norte,
sur = if (extremes_arclim$sur[2] < extremes_pred$sur[2]) extremes_arclim$sur else extremes_pred$sur,
este = if (extremes_arclim$este[1] > extremes_pred$este[1]) extremes_arclim$este else extremes_pred$este,
oeste = if (extremes_arclim$oeste[1] < extremes_pred$oeste[1]) extremes_arclim$oeste else extremes_pred$oeste
)
# Definir la extensiÃ³n del recorte basado en el cuadrado rojo
recorte_extent <- ext(extreme_global$oeste[1], extreme_global$este[1], extreme_global$sur[2], extreme_global$norte[2])
# Recortar ambos mapas al cuadrado definido
arclim_recortado <- crop(arclim_binary, recorte_extent)
pred_recortado <- crop(pred_binary, recorte_extent)
# Guardar los mapas recortados como archivos .tif
writeRaster(arclim_recortado, "arclim_recortado.tif", overwrite=TRUE)
# Imprimir resultados
print("Extremos Globales (mÃ¡ximos entre ambos mapas):")
print(extreme_global)
print("Archivos .tif generados: arclim_recortado.tif y pred_recortado.tif")
# VisualizaciÃ³n de los mapas binarios recortados
plot(arclim_recortado, main="Mapa ARClim Recortado")
plot(pred_recortado, main="Mapa PredicciÃ³n Recortado")
# visualizar diferencias entre modelos ------------------------------------
#diff_future <- pred_future_resampled - arclim_future
diff_present_recortado <- pred_recortado - arclim_recortado
# Crear una paleta de colores para resaltar diferencias
diff_palette <- colorRampPalette(c("blue", "white", "red"))  # Azul (-), Blanco (0), Rojo (+)
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlim = c(-77, -66), ylim = c(-56, -17), asp=1,
cex.main = 0.85,
col = diff_palette(100))
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlim = c(-77, -66), ylim = c(-35, -17), asp=1,
cex.main = 0.85,
col = diff_palette(100))
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
cex.main = 0.85,
col = diff_palette(100))
values_present_dismo <- values(pred_recortado)
values_present_arclim <- values(arclim_recortado)
# Calcular correlaciones
#cor_future <- cor(values_future_dismo, values_future_arclim, use = "complete.obs")
cor_present <- cor(values_present_dismo, values_present_arclim, use = "complete.obs")
# Mostrar resultados
print(paste("CorrelaciÃ³n DISMO vs ARCLIM (1980-2010):", round(cor_present, 3)))
# 2. Convertir los mapas binarizados a vectores
pred_values <- values(pred_binary)
arclim_values <- values(arclim_binary)
# 3. Remover valores NA para evitar problemas en la comparaciÃ³n
valid_indices <- !is.na(pred_values) & !is.na(arclim_values)
pred_values <- pred_values[valid_indices]
arclim_values <- arclim_values[valid_indices]
# 4. Crear la tabla cruzada (Matriz de ConfusiÃ³n)
confusion_matrix <- table(pred_values, arclim_values)
# Mostrar la matriz de confusiÃ³n
print(confusion_matrix)
# FUTURE TIME (2035-2065) -------------------------------------------------------------------------
# Transformar los mapas a binario con umbral de 0.1
arclim_binary_future <- arclim_future >= 0.1
pred_binary_future <- pred_future_resampled >= 0.1
# Encontrar los pÃ­xeles con valor 1 en cada mapa
arclim_cells_future <- which(arclim_binary_future[] == 1)
pred_cells_future <- which(pred_binary_future[] == 1)
# Obtener coordenadas de los pÃ­xeles con valor 1
coords_arclim_future <- xyFromCell(arclim_binary_future, arclim_cells_future)
coords_pred_futre <- xyFromCell(pred_binary_future, pred_cells_future)
# Encontrar los extremos de CADA MAPA
extremes_arclim_future <- list(
norte = coords_arclim_future[which.max(coords_arclim_future[,2]),],
sur = coords_arclim_future[which.min(coords_arclim_future[,2]),],
este = coords_arclim_future[which.max(coords_arclim_future[,1]),],
oeste = coords_arclim_future[which.min(coords_arclim_future[,1]),]
)
extremes_pred_future <- list(
norte = coords_pred_future[which.max(coords_pred_future[,2]),],
sur = coords_pred_future[which.min(coords_pred_future[,2]),],
este = coords_pred_future[which.max(coords_pred_future[,1]),],
oeste = coords_pred_future[which.min(coords_pred_future[,1]),]
)
# Seleccionar la coordenada extrema global
extreme_global_future <- list(
norte = if (extremes_arclim_future$norte[2] > extremes_pred_future$norte[2]) extremes_arclim_future$norte else extremes_pred_future$norte,
sur = if (extremes_arclim_future$sur[2] < extremes_pred_future$sur[2]) extremes_arclim_future$sur else extremes_pred_future$sur,
este = if (extremes_arclim_future$este[1] > extremes_pred_future$este[1]) extremes_arclim_future$este else extremes_pred_future$este,
oeste = if (extremes_arclim_future$oeste[1] < extremes_pred_future$oeste[1]) extremes_arclim_future$oeste else extremes_pred_future$oeste
)
# Definir la extensiÃ³n del recorte basado en el cuadrado rojo
recorte_extent_future <- ext(extreme_global_future$oeste[1], extreme_global_future$este[1], extreme_global_future$sur[2], extreme_global_future$norte[2])
# Recortar ambos mapas al cuadrado definido
arclim_recortado_future <- crop(arclim_binary_future, recorte_extent_future)
# Definir la extensiÃ³n del recorte basado en el cuadrado rojo
recorte_extent_future <- ext(extreme_global_future$oeste[1], extreme_global_future$este[1], extreme_global_future$sur[2], extreme_global_future$norte[2])
# Seleccionar la coordenada extrema global
extreme_global_future <- list(
norte = if (extremes_arclim_future$norte[2] > extremes_pred_future$norte[2]) extremes_arclim_future$norte else extremes_pred_future$norte,
sur = if (extremes_arclim_future$sur[2] < extremes_pred_future$sur[2]) extremes_arclim_future$sur else extremes_pred_future$sur,
este = if (extremes_arclim_future$este[1] > extremes_pred_future$este[1]) extremes_arclim_future$este else extremes_pred_future$este,
oeste = if (extremes_arclim_future$oeste[1] < extremes_pred_future$oeste[1]) extremes_arclim_future$oeste else extremes_pred_future$oeste
)
extremes_pred_future <- list(
norte = coords_pred_future[which.max(coords_pred_future[,2]),],
sur = coords_pred_future[which.min(coords_pred_future[,2]),],
este = coords_pred_future[which.max(coords_pred_future[,1]),],
oeste = coords_pred_future[which.min(coords_pred_future[,1]),]
)
coords_pred_futre <- xyFromCell(pred_binary_future, pred_cells_future)
# Encontrar los extremos de CADA MAPA
extremes_arclim_future <- list(
norte = coords_arclim_future[which.max(coords_arclim_future[,2]),],
sur = coords_arclim_future[which.min(coords_arclim_future[,2]),],
este = coords_arclim_future[which.max(coords_arclim_future[,1]),],
oeste = coords_arclim_future[which.min(coords_arclim_future[,1]),]
)
extremes_pred_future <- list(
norte = coords_pred_future[which.max(coords_pred_future[,2]),],
sur = coords_pred_future[which.min(coords_pred_future[,2]),],
este = coords_pred_future[which.max(coords_pred_future[,1]),],
oeste = coords_pred_future[which.min(coords_pred_future[,1]),]
)
coords_pred_future <- xyFromCell(pred_binary_future, pred_cells_future)
# Encontrar los extremos de CADA MAPA
extremes_arclim_future <- list(
norte = coords_arclim_future[which.max(coords_arclim_future[,2]),],
sur = coords_arclim_future[which.min(coords_arclim_future[,2]),],
este = coords_arclim_future[which.max(coords_arclim_future[,1]),],
oeste = coords_arclim_future[which.min(coords_arclim_future[,1]),]
)
extremes_pred_future <- list(
norte = coords_pred_future[which.max(coords_pred_future[,2]),],
sur = coords_pred_future[which.min(coords_pred_future[,2]),],
este = coords_pred_future[which.max(coords_pred_future[,1]),],
oeste = coords_pred_future[which.min(coords_pred_future[,1]),]
)
# Seleccionar la coordenada extrema global
extreme_global_future <- list(
norte = if (extremes_arclim_future$norte[2] > extremes_pred_future$norte[2]) extremes_arclim_future$norte else extremes_pred_future$norte,
sur = if (extremes_arclim_future$sur[2] < extremes_pred_future$sur[2]) extremes_arclim_future$sur else extremes_pred_future$sur,
este = if (extremes_arclim_future$este[1] > extremes_pred_future$este[1]) extremes_arclim_future$este else extremes_pred_future$este,
oeste = if (extremes_arclim_future$oeste[1] < extremes_pred_future$oeste[1]) extremes_arclim_future$oeste else extremes_pred_future$oeste
)
# Definir la extensiÃ³n del recorte basado en el cuadrado rojo
recorte_extent_future <- ext(extreme_global_future$oeste[1], extreme_global_future$este[1], extreme_global_future$sur[2], extreme_global_future$norte[2])
# Recortar ambos mapas al cuadrado definido
arclim_recortado_future <- crop(arclim_binary_future, recorte_extent_future)
pred_recortado_future <- crop(pred_binary_future, recorte_extent_future)
# Imprimir resultados
print("Extremos Globales (mÃ¡ximos entre ambos mapas):")
print(extreme_global_future)
# VisualizaciÃ³n de los mapas binarios recortados
plot(arclim_recortado_future, main="Mapa ARClim Recortado")
plot(pred_recortado_future, main="Mapa PredicciÃ³n Recortado")
# VisualizaciÃ³n de los mapas binarios recortados
plot(arclim_recortado_future, main="Mapa ARClim Future Recortado")
plot(pred_recortado_future, main="Mapa PredicciÃ³n Future Recortado")
# visualizar diferencias entre modelos ------------------------------------
diff_future <- pred_recortado_future - arclim_recortado_future
diff_present_recortado <- pred_recortado - arclim_recortado
# Crear una paleta de colores para resaltar diferencias
diff_palette <- colorRampPalette(c("blue", "white", "red"))  # Azul (-), Blanco (0), Rojo (+)
# Graficar diferencias espaciales
par(mfcol = c(1,2))
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
cex.main = 0.85,
col = diff_palette(100))
plot(diff_future, main = "Diferencia DISMO - ARCLIM \n(2035-2065)",
xlim = c(-77, -66), ylim = c(-56, -17), asp=1,
cex.main = 0.85,
col = diff_palette(100))
plot(diff_future, main = "Diferencia DISMO - ARCLIM \n(2035-2065)",
cex.main = 0.85,
col = diff_palette(100))
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
cex.main = 0.85,
col = diff_palette(100))
plot(diff_future, main = "Diferencia DISMO - ARCLIM \n(2035-2065)",
cex.main = 0.85,
col = diff_palette(100))
mapview(diff_present_recortado)
library(mapview)
mapview(diff_present_recortado)
# Extraer valores de las capas
values_future_dismo <- values(pred_recortado_future)
values_future_arclim <- values(arclim_recortado_future)
values_present_dismo <- values(pred_recortado)
values_present_arclim <- values(arclim_recortado)
# Calcular correlaciones
cor_future <- cor(values_future_dismo, values_future_arclim, use = "complete.obs")
cor_present <- cor(values_present_dismo, values_present_arclim, use = "complete.obs")
# Mostrar resultados
print(paste("CorrelaciÃ³n DISMO vs ARCLIM (1980-2010):", round(cor_present, 3)))
print(paste("CorrelaciÃ³n DISMO vs ARCLIM (2035-2065):", round(cor_future, 3)))
# 2. Convertir los mapas binarizados a vectores
pred_values_future <- values(pred_recortado_future)
arclim_values_future <- values(arclim_recortado_future)
# 3. Remover valores NA para evitar problemas en la comparaciÃ³n
valid_indices_future <- !is.na(pred_values_future) & !is.na(arclim_values_future)
pred_values_future <- pred_values_future[valid_indices_future]
arclim_values_future <- arclim_values_future[valid_indices_future]
# 4. Crear la tabla cruzada (Matriz de ConfusiÃ³n)
confusion_matrix_future <- table(pred_values_future, arclim_values_future)
# Mostrar la matriz de confusiÃ³n
print(confusion_matrix_future)
# 5. Calcular el Ã­ndice de Kappa usando caret
conf_matrix_future <- confusionMatrix(confusion_matrix_future)
library(caret)
# 5. Calcular el Ã­ndice de Kappa usando caret
conf_matrix_future <- confusionMatrix(confusion_matrix_future)
# Mostrar el Ã­ndice de Kappa
print(conf_matrix_future$overall["Kappa"])
# VisualizaciÃ³n de los mapas binarios recortados
plot(arclim_recortado, main="Mapa ARClim 1980-2010")
plot(pred_recortado, main="Mapa PredicciÃ³n 1980-2010")
# VisualizaciÃ³n de los mapas binarios recortados
plot(pred_recortado, main="Mapa PredicciÃ³n 1980-2010")
# VisualizaciÃ³n de los mapas binarios recortados
plot(pred_recortado, main="Mapa Dismo 1980-2010")
plot(arclim_recortado, main="Mapa ARClim 1980-2010")
# VisualizaciÃ³n de los mapas binarios recortados
plot(pred_recortado_future, main="Mapa Dismo 2035-2065")
plot(arclim_recortado_future, main="Mapa ARClim 2035-2065")
# visualizar diferencias entre modelos ------------------------------------
diff_future <- pred_recortado_future - arclim_recortado_future
diff_present_recortado <- pred_recortado - arclim_recortado
# Crear una paleta de colores para resaltar diferencias
diff_palette <- colorRampPalette(c("blue", "white", "red"))  # Azul (-), Blanco (0), Rojo (+)
# Graficar diferencias espaciales
par(mfcol = c(1,2))
plot(diff_present_recortado, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
cex.main = 0.85,
col = diff_palette(100))
plot(diff_future, main = "Diferencia DISMO - ARCLIM \n(2035-2065)",
cex.main = 0.85,
col = diff_palette(100))
# ðŸ“Œ 1. Binarizar los mapas presentes
pred_present_bin <- pred_present_resampled > 0.5
# 2. Convertir los mapas binarizados a vectores
pred_values <- values(pred_recortado)
arclim_values <- values(arclim_recortado)
# 3. Remover valores NA para evitar problemas en la comparaciÃ³n
valid_indices <- !is.na(pred_values) & !is.na(arclim_values)
pred_values <- pred_values[valid_indices]
arclim_values <- arclim_values[valid_indices]
# 4. Crear la tabla cruzada (Matriz de ConfusiÃ³n)
confusion_matrix <- table(pred_values, arclim_values)
# Mostrar la matriz de confusiÃ³n
print(confusion_matrix)
# 5. Calcular el Ã­ndice de Kappa usando caret
conf_matrix <- confusionMatrix(confusion_matrix)
# Mostrar el Ã­ndice de Kappa
print(conf_matrix$overall["Kappa"])
# Extraer valores de las capas
values_future_dismo <- values(pred_recortado_future)
values_future_arclim <- values(arclim_recortado_future)
values_present_dismo <- values(pred_recortado)
values_present_arclim <- values(arclim_recortado)
# Calcular correlaciones
cor_future <- cor(values_future_dismo, values_future_arclim, use = "complete.obs")
cor_present <- cor(values_present_dismo, values_present_arclim, use = "complete.obs")
# Mostrar resultados
print(paste("CorrelaciÃ³n DISMO vs ARCLIM (1980-2010):", round(cor_present, 3)))
print(paste("CorrelaciÃ³n DISMO vs ARCLIM (2035-2065):", round(cor_future, 3)))
hist(values(diff_present_recortado), breaks = 50, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlab = "Diferencia de probabilidad", col = "blue")
hist(values(diff_future), breaks = 50, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlab = "Diferencia de probabilidad", col = "blue")
hist(values(diff_present_recortado), breaks = 50, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlab = "Diferencia de probabilidad", col = "blue")
hist(values(diff_future), breaks = 50, main = "Diferencia DISMO - ARCLIM \n(2035-2065)",
xlab = "Diferencia de probabilidad", col = "blue")
hist(values(diff_present_recortado), breaks = 3, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlab = "Diferencia de probabilidad", col = "blue")
hist(values(diff_present_recortado), breaks = 50, main = "Diferencia DISMO - ARCLIM \n(1980-2010)",
xlab = "Diferencia de probabilidad", col = "blue")
# Contar la frecuencia de cada categorÃ­a en los datos presentes
diff_present_values <- values(diff_present_recortado)
diff_present_freq <- table(factor(diff_present_values, levels = c(-1, 0, 1)))  # Asegura que -1, 0 y 1 aparezcan siempre
# Contar la frecuencia de cada categorÃ­a en los datos futuros
diff_future_values <- values(diff_future)
diff_future_freq <- table(factor(diff_future_values, levels = c(-1, 0, 1)))  # Asegura que -1, 0 y 1 aparezcan siempre
# Graficar el grÃ¡fico de barras para los datos presentes
barplot(diff_present_freq, main = "Diferencia DISMO - ARCLIM (1980-2010)",
xlab = "Diferencia de probabilidad", ylab = "Frecuencia",
col = "blue", names.arg = c("-1", "0", "1"))
# Graficar el grÃ¡fico de barras para los datos futuros
barplot(diff_future_freq, main = "Diferencia DISMO - ARCLIM (2035-2065)",
xlab = "Diferencia de probabilidad", ylab = "Frecuencia",
col = "blue", names.arg = c("-1", "0", "1"))
install.packages("biomod2", dependencies = TRUE)
